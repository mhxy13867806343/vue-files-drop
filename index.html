<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>æ–‡ä»¶å¤¹ç®¡ç†å™¨</title>
  <!-- Vue 3.2 CDN -->
  <script src="https://unpkg.com/vue@3.2.47/dist/vue.global.js"></script>
  <!-- Element Plus -->
  <link rel="stylesheet" href="https://unpkg.com/element-plus@2.3.7/dist/index.css" />
  <script src="https://unpkg.com/element-plus@2.3.7/dist/index.full.js"></script>
  <script src="https://unpkg.com/@element-plus/icons-vue"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Microsoft YaHei', sans-serif;
      background-color: #f5f5f5;
      color: #333;
    }
    
    .app-container {
      max-width: 1200px;
      margin: 20px auto;
      padding: 20px;
      background-color: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }
    
    .header-buttons {
      display: flex;
      gap: 10px;
    }
    
    .btn-action {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
    }
    
    .btn-action:hover {
      opacity: 0.9;
    }
    
    .btn-save {
      background-color: #4CAF50;
      color: white;
    }
    
    .drag-area {
      border: 2px dashed #ccc;
      background-color: rgba(0, 0, 0, 0.02);
    }
    
    .drag-active {
      border-color: #4CAF50;
      background-color: rgba(76, 175, 80, 0.1);
    }
    
    .folder-container {
      position: relative;
      min-height: 400px;
      padding: 20px;
      border: 1px dashed #ddd;
      border-radius: 4px;
      user-select: none;
    }
    
    .folders-list {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
    }
    
    .folder-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: auto;
      height: 100px;
      padding: 10px;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
      z-index: 1;
      user-select: none; /* é˜²æ­¢æ‹–åŠ¨æ—¶é€‰æ‹©æ–‡æœ¬ */
    }
    
    .folder-item.dragging {
      opacity: 0.7;
      transform: scale(1.05);
      z-index: 10;
    }
    
    .folder-item.drag-over {
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
      background-color: rgba(0, 0, 0, 0.05);
    }
    
    .folder-item:hover {
      background-color: rgba(0, 0, 0, 0.05);
    }
    
    .folder-item.hover {
      background-color: rgba(0, 0, 0, 0.08);
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
    }
    
    .folder-item.selected {
      background-color: rgba(25, 118, 210, 0.2);
      outline: 3px solid #1976d2;
      box-shadow: 0 0 8px rgba(25, 118, 210, 0.5);
    }
    
    .folder-item.selected.hover {
      background-color: rgba(25, 118, 210, 0.25);
    }
    
    .selection-info {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(25, 118, 210, 0.1);
      border: 1px solid #1976d2;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 14px;
      color: #1976d2;
      z-index: 100;
    }
    
    .selection-box {
      position: fixed;
      border: 2px solid rgba(25, 118, 210, 0.8);
      background-color: rgba(25, 118, 210, 0.15);
      z-index: 90;
      pointer-events: none;
      box-shadow: 0 0 10px rgba(25, 118, 210, 0.4);
    }
    
    .selection-actions {
      display: flex;
      gap: 8px;
    }
    
    .selection-actions button {
      padding: 2px 8px;
      border: none;
      border-radius: 3px;
      background-color: #4CAF50;
      color: white;
      cursor: pointer;
      font-size: 12px;
    }
    
    .selection-actions button.delete {
      background-color: #f44336;
    }
    
    .keyboard-shortcuts {
      margin-top: 10px;
      padding: 10px;
      background-color: #f5f5f5;
      border-radius: 4px;
      font-size: 12px;
      line-height: 1.6;
    }
    
    .folder-icon {
      font-size: 40px;
      color: #ffc107;
      margin-bottom: 8px;
    }
    
    .folder-name {
      font-size: 14px;
      text-align: center;
      word-break: break-word;
      overflow: hidden;
      max-height: 42px;
      width: 100%;
    }
    
    .folder-name-input {
      width: 100%;
      padding: 4px 6px;
      text-align: center;
      border: 1px solid #ddd;
      border-radius: 3px;
      outline: none;
      font-size: 14px;
    }
    
    .context-menu {
      position: fixed;
      background: white;
      border: 1px solid #ddd;
      border-radius: 4px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      z-index: 1000;
      min-width: 200px;
      font-size: 14px;
    }
    
    .menu-item {
      padding: 10px 15px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    
    .menu-item:hover {
      background-color: #f5f5f5;
    }
    
    .empty-text {
      text-align: center;
      padding: 40px 0;
      color: #999;
      font-style: italic;
    }
    
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 10px;
      border-bottom: 1px solid #eee;
    }
    
    .hint {
      margin-top: 20px;
      color: #666;
      font-size: 13px;
      padding: 10px;
      background-color: #f0f8ff;
      border-radius: 4px;
      line-height: 1.6;
    }
    
    .file-icon {
      color: #2196F3;
    }
  </style>
</head>
<body>
  <div id="app">
    <div class="app-container">
      <div class="header">
        <h2>æ–‡ä»¶å¤¹ç®¡ç†å™¨({{folders.length}})</h2>
        <div class="header-buttons">
          <el-button @click="createNewFolder" class="btn-action">æ–°å»ºæ–‡ä»¶å¤¹</el-button>
          <el-button
          v-if="folders.length"
          @click="saveData" class="btn-action btn-save">ä¿å­˜</el-button>
          <el-button
          v-if="folders.length"
          type="warning"
          @click="clearData" class="btn-action btn-save">æ¸…é™¤</el-button>
        </div>
      </div>

      <div 
        class="folder-container" 
        @click="handleContainerClick($event)"
        @contextmenu.prevent="showContextMenu($event)"
        @mousedown="startDragSelection($event)"
        @mousemove="updateDragSelection($event)"
        @mouseup="endDragSelection($event)"
        @mouseleave="endDragSelection($event)"
        @dragover="onDragOver"
        @dragleave="onDragLeave"
        @drop="onDrop"
        :class="{ 'drag-area': isDragging, 'drag-active': isDraggingActive }"
      >
        <!-- æ–‡ä»¶å¤¹åˆ—è¡¨ -->
        <div v-if="folders.length > 0" class="folders-list">
          <div 
            v-for="(folder, index) in folders" 
            :key="folder.id" 
            class="folder-item"
            :data-id="folder.id"
            :class="{ 
              'selected': selectedFolders.includes(folder.id),
              'hover': hoveredFolderId === folder.id,
              'dragging': draggedFolder && draggedFolder.id === folder.id,
              'drag-over': dragOverFolder && dragOverFolder.id === folder.id
            }"
            @click.stop="handleFolderClick(folder, index, $event)"
            @contextmenu.stop.prevent="showContextMenu($event, folder)"
            @dblclick="startEdit(folder)"
            @mouseover="onFolderMouseOver(folder)"
            @mouseleave="onFolderMouseLeave(folder)"
            draggable="true"
            @dragstart="handleDragStart($event, folder, index)"
            @dragover.prevent="handleDragOver($event, folder, index)"
            @drop.prevent="handleDrop($event, folder, index)"
          >
            <template v-if="editingFolder && editingFolder.id === folder.id">
              <div class="folder-icon" :class="{'file-icon': folder.isFile}">{{ folder.isFile ? 'ğŸ“„' : 'ğŸ“' }}</div>
              <input 
                ref="editInput"
                v-model="editingFolder.name" 
                @blur="finishEdit" 
                @keyup.enter="finishEdit"
                @keyup.esc="cancelEdit"
                class="folder-name-input"
                v-focus
              />
            </template>
            <template v-else>
              <div class="folder-icon" :class="{'file-icon': folder.isFile}">{{ folder.isFile ? 'ğŸ“„' : 'ğŸ“' }}</div>
              <div class="folder-name">{{ folder.name }}</div>
            </template>
          </div>
        </div>
        
        <!-- ç©ºçŠ¶æ€ -->
        <div v-else class="empty-text">
          å³é”®ç‚¹å‡»åˆ›å»ºä¸€ä¸ªæ–°çš„æ–‡ä»¶å¤¹
        </div>
        
        <!-- æ¡†é€‰ -->
        <div 
          v-show="isSelectionActive"
          class="selection-box"
          :style="{
            left: `${Math.min(selectionStart.x, selectionCurrent.x)}px`,
            top: `${Math.min(selectionStart.y, selectionCurrent.y)}px`,
            width: `${Math.abs(selectionCurrent.x - selectionStart.x)}px`,
            height: `${Math.abs(selectionCurrent.y - selectionStart.y)}px`
          }"
        ></div>

        <!-- å³é”®èœå• -->
        <div 
          v-show="contextMenuVisible" 
          class="context-menu"
          :style="{ top: contextMenuTop + 'px', left: contextMenuLeft + 'px' }"
        >
          <!-- é€šç”¨èœå•é¡¹ -->
          <div v-if="folders.length > 0" class="menu-item" @click="selectAllFolders">å…¨é€‰</div>
          <div v-if="selectedFolders.length > 0" class="menu-item" @click="clearSelection">å–æ¶ˆé€‰æ‹©</div>
          <div class="menu-item" @click="createNewFolder">åˆ›å»ºæ–°æ–‡ä»¶å¤¹</div>
          <div v-if="clipboardData" class="menu-item" @click="pasteFolder">ç²˜è´´</div>
          
          <!-- å¤šé€‰æ¨¡å¼ä¸‹çš„èœå•é¡¹ -->
          <template v-if="selectedFolders.length > 1 && selectedFolder && selectedFolders.includes(selectedFolder.id)">
            <div class="menu-item" @click="copySelectedFolders">å¤åˆ¶é€‰ä¸­çš„ {{selectedFolders.length}} ä¸ªé¡¹ç›®</div>
            <div class="menu-item" @click="deleteSelectedFolders">åˆ é™¤é€‰ä¸­çš„ {{selectedFolders.length}} ä¸ªé¡¹ç›®</div>
          </template>
          
          <!-- å•é€‰æ¨¡å¼ä¸‹çš„èœå•é¡¹ -->
          <template v-else-if="selectedFolder">
            <div class="menu-item" @click="startEdit(selectedFolder)">é‡å‘½å</div>
            <div class="menu-item" @click="copyFolder(selectedFolder)">å¤åˆ¶</div>
            <div class="menu-item" @click="deleteFolder(selectedFolder)">åˆ é™¤</div>
          </template>
        </div>
      </div>
      
      <div class="hint">
        <strong>æç¤ºï¼š</strong><br>
        - å³é”®ç‚¹å‡»ç©ºç™½åŒºåŸŸåˆ›å»ºæ–°æ–‡ä»¶å¤¹<br>
        - åŒå‡»æ–‡ä»¶å¤¹åç§°è¿›è¡Œä¿®æ”¹<br>
        - å³é”®ç‚¹å‡»æ–‡ä»¶å¤¹å¯ä»¥å¤åˆ¶ã€é‡å‘½åæˆ–åˆ é™¤<br>
        - å°†æ–‡ä»¶å¤¹æ‹–æ‹½åˆ°æ­¤åŒºåŸŸä¸Šä¼ <br>
        - ç‚¹å‡»"ä¿å­˜"æŒ‰é’®æˆ–å…³é—­é¡µé¢æ—¶ä¼šè‡ªåŠ¨ä¿å­˜<br>
        - å¤åˆ¶åå¯ä»¥åœ¨ç©ºç™½åŒºåŸŸå³é”®é€‰æ‹©ç²˜è´´
      </div>
      
      <div class="keyboard-shortcuts">
        <strong>æ“ä½œæç¤ºï¼š</strong><br>
        - <kbd>Ctrl</kbd> + ç‚¹å‡»ï¼šå¤šé€‰æ–‡ä»¶å¤¹<br>
        - <kbd>Shift</kbd> + ç‚¹å‡»ï¼šè¿ç»­é€‰æ‹©æ–‡ä»¶å¤¹<br>
        - <kbd>Ctrl+A</kbd> æˆ– å³é”®èœå•å…¨é€‰ï¼šé€‰æ‹©æ‰€æœ‰æ–‡ä»¶å¤¹<br>
        - <kbd>Ctrl+C</kbd> æˆ– å³é”®èœå•å¤åˆ¶ï¼šå¤åˆ¶é€‰ä¸­æ–‡ä»¶å¤¹<br>
        - <kbd>Ctrl+V</kbd> æˆ– å³é”®èœå•ç²˜è´´ï¼šç²˜è´´æ–‡ä»¶å¤¹<br>
        - <kbd>Delete</kbd> æˆ– å³é”®èœå•åˆ é™¤ï¼šåˆ é™¤é€‰ä¸­æ–‡ä»¶å¤¹<br>
        - <kbd>Esc</kbd> æˆ– ç©ºç™½åŒºåŸŸç‚¹å‡» æˆ– å³é”®èœå•å–æ¶ˆé€‰æ‹©ï¼šå–æ¶ˆé€‰æ‹©
      </div>
      
      <!-- é€‰ä¸­ä¿¡æ¯æç¤º -->
      <div v-if="selectedFolders.length > 0" class="selection-info">
        å·²é€‰æ‹© {{ selectedFolders.length }} ä¸ªé¡¹ç›®
        <div class="selection-actions">
          <button @click="copySelectedFolders">å¤åˆ¶</button>
          <button class="delete" @click="deleteSelectedFolders">åˆ é™¤</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    const { createApp, ref, nextTick, onMounted, onBeforeUnmount } = Vue;
    // è‡ªå®šä¹‰æŒ‡ä»¤ï¼šè‡ªåŠ¨èšç„¦
    const vFocus = {
      mounted: (el) => el.focus()
    };

    const app = createApp({
      directives: {
        focus: vFocus
      },
      setup() {
        // æ–‡ä»¶å¤¹æ•°æ®
        const folders = ref([]);
        let nextId = 1;
        
        // æ‹–æ‹½çŠ¶æ€
        const isDragging = ref(false);
        const isDraggingActive = ref(false);
        
        // å˜æ›´è·Ÿè¸ª
        const hasChanges = ref(false);
        const originalData = ref('');
        
        // å¤åˆ¶ç²˜è´´çŠ¶æ€
        const clipboardData = ref(null);
        
        // å¤šé€‰åŠŸèƒ½
        const selectedFolders = ref([]);
        const ctrlKeyPressed = ref(false);
        const shiftKeyPressed = ref(false);
        const lastSelectedIndex = ref(-1);
        
        // é¼ æ ‡æ‚¬åœçŠ¶æ€
        const hoveredFolderId = ref(null);
        
        // æ¡†é€‰çŠ¶æ€
        const isSelectionActive = ref(false);
        const selectionStart = ref({ x: 0, y: 0 });
        const selectionCurrent = ref({ x: 0, y: 0 });
        const folderElements = ref([]);
        
        // æ‹–æ‹½çŠ¶æ€
        const draggedFolder = ref(null);
        const dragOverFolder = ref(null);
        const isDraggingFolder = ref(false);
        const dragStartX = ref(0);
        const dragStartY = ref(0);

        // å³é”®èœå•çŠ¶æ€
        const contextMenuVisible = ref(false);
        const contextMenuTop = ref(0);
        const contextMenuLeft = ref(0);
        const selectedFolder = ref(null);

        // ç¼–è¾‘çŠ¶æ€
        const editingFolder = ref(null);
        const editInput = ref(null);
        const tempName = ref('');

        // æ˜¾ç¤ºå³é”®èœå•
        const showContextMenu = (event, folder = null) => {
          // è®¡ç®—èœå•ä½ç½®
          contextMenuTop.value = event.clientY;
          contextMenuLeft.value = event.clientX;
          
          // ç¡®ä¿èœå•ä¸ä¼šè¶…å‡ºè§†å£
          const viewportHeight = window.innerHeight;
          const viewportWidth = window.innerWidth;
          // åŠ¨æ€è®¡ç®—èœå•é«˜åº¦
          let menuHeight = 40; // é»˜è®¤ä»…æœ‰åˆ›å»ºæ–‡ä»¶å¤¹
          
          if (clipboardData.value && !folder) menuHeight += 40; // åŠ ä¸Šç²˜è´´é€‰é¡¹
          if (folder) {
            if (selectedFolders.length > 1 && selectedFolders.includes(folder.id)) {
              menuHeight = 120; // å¤šé€‰æ¨¡å¼ä¸‹çš„èœå•é«˜åº¦
            } else {
              menuHeight = 160; // å•é€‰æ¨¡å¼ä¸‹çš„èœå•é«˜åº¦
            }
          }
          
          const menuWidth = 240; // å¢åŠ èœå•å®½åº¦ä»¥é€‚åº”æ–‡å­—
          
          if (contextMenuTop.value + menuHeight > viewportHeight) {
            contextMenuTop.value = viewportHeight - menuHeight;
          }
          
          if (contextMenuLeft.value + menuWidth > viewportWidth) {
            contextMenuLeft.value = viewportWidth - menuWidth;
          }
          
          contextMenuVisible.value = true;
          selectedFolder.value = folder;
          
          // å¦‚æœå³é”®ç‚¹å‡»çš„æ˜¯æœªé€‰ä¸­çš„æ–‡ä»¶å¤¹ï¼Œè€Œä¸”æ²¡æœ‰æŒ‰ä¸‹Ctrlé”®ï¼Œåˆ™æ¸…é™¤å½“å‰é€‰æ‹©å¹¶é€‰ä¸­è¯¥æ–‡ä»¶å¤¹
          if (folder && !selectedFolders.value.includes(folder.id) && !ctrlKeyPressed.value) {
            selectedFolders.value = [folder.id];
            const index = folders.value.findIndex(f => f.id === folder.id);
            if (index !== -1) {
              lastSelectedIndex.value = index;
            }
          }
        };

        // åˆ›å»ºæ–°æ–‡ä»¶å¤¹
        const createNewFolder = () => {
          if (folders.value.length >= 20) {
            ElementPlus.ElMessage.info("æœ€å¤šæ–‡ä»¶å¤¹åªèƒ½åˆ›å»º 20 ä¸ª,è¯·å…ˆç§»é™¤éƒ¨åˆ†åï¼Œå†æ·»åŠ !")
            contextMenuVisible.value = false;
            return;
          }
          
          // ç”Ÿæˆæ–°æ–‡ä»¶å¤¹å
          let baseName = 'æ–°å»ºæ–‡ä»¶å¤¹';
          let folderName = baseName;
          let counter = 1;
          
          // æ£€æŸ¥æ˜¯å¦æœ‰é‡åæ–‡ä»¶å¤¹ï¼Œå¦‚æœæœ‰å°±è‡ªåŠ¨è¿½åŠ æ•°å­—
          while (folders.value.some(f => f.name === folderName)) {
            folderName = `${baseName}${counter}`;
            counter++;
          }
          
          const newFolder = { 
            id: nextId++, 
            name: folderName
          };
          
          folders.value.push(newFolder);
          contextMenuVisible.value = false;
          hasChanges.value = true;
          
          ElementPlus.ElMessage({
            message: `æˆåŠŸåˆ›å»ºã€Œ${folderName}ã€`,
            type: 'success',
            duration: 1500
          });
          
          // åˆ›å»ºåç«‹å³è¿›å…¥ç¼–è¾‘æ¨¡å¼
          nextTick(() => {
            startEdit(newFolder);
          });
        };

        // å¼€å§‹ç¼–è¾‘æ–‡ä»¶å¤¹åç§°
        const startEdit = (folder) => {
          tempName.value = folder.name;
          editingFolder.value = { ...folder };
          contextMenuVisible.value = false;
          
          // ç¡®ä¿è¾“å…¥æ¡†è·å¾—ç„¦ç‚¹
          nextTick(() => {
            // editInputæ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œæˆ‘ä»¬è·å–ç¬¬ä¸€ä¸ªå…ƒç´ 
            if (editInput.value && editInput.value.length > 0) {
              // å¯¹äºæ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½å°è¯•åº”ç”¨focus
              editInput.value.forEach(input => {
                if (input && typeof input.focus === 'function') {
                  input.focus();
                  input.select();
                }
              });
            } else if (editInput.value && typeof editInput.value.focus === 'function') {
              // å¦‚æœä¸æ˜¯æ•°ç»„ä½†æ˜¯æ˜¯å•ä¸ªå…ƒç´ 
              editInput.value.focus();
              editInput.value.select();
            }
          });
        };

        // å®Œæˆç¼–è¾‘
        const finishEdit = () => {
          if (editingFolder.value) {
            const index = folders.value.findIndex(f => f.id === editingFolder.value.id);
            if (index !== -1) {
              // éªŒè¯åç§°ä¸ä¸ºç©º
              if (editingFolder.value.name.trim() === '') {
                editingFolder.value.name = tempName.value;
                ElementPlus.ElMessage.warning('æ–‡ä»¶å¤¹åç§°ä¸èƒ½ä¸ºç©º');
              } else {
                // æ£€æŸ¥æ˜¯å¦å­˜åœ¨é‡å
                const trimmedName = editingFolder.value.name.trim();
                const duplicateName = folders.value.find(
                  f => f.id !== editingFolder.value.id && f.name === trimmedName
                );
                
                if (duplicateName) {
                  ElementPlus.ElMessage.error('æ–‡ä»¶å¤¹åç§°ã€Œ' + trimmedName + 'ã€å·²å­˜åœ¨ï¼Œè¯·ä½¿ç”¨å…¶ä»–åç§°');
                  editingFolder.value.name = tempName.value;
                } else if (folders.value[index].name !== trimmedName) {
                  // åªæœ‰å½“åç§°çœŸçš„æ”¹å˜æ—¶æ‰æ ‡è®°å˜æ›´
                  folders.value[index].name = trimmedName;
                  hasChanges.value = true;
                  ElementPlus.ElMessage({
                    message: 'æ–‡ä»¶å¤¹é‡å‘½åæˆåŠŸ',
                    type: 'success'
                  });
                }
              }
            }
            editingFolder.value = null;
          }
        };

        // å–æ¶ˆç¼–è¾‘
        const cancelEdit = () => {
          editingFolder.value = null;
        };

        // åˆ é™¤æ–‡ä»¶å¤¹
        const deleteFolder = (folder) => {
          ElementPlus.ElMessageBox.confirm(
            `ç¡®å®šè¦åˆ é™¤æ–‡ä»¶å¤¹ã€Œ${folder.name}ã€å—ï¼Ÿ`,
            'åˆ é™¤ç¡®è®¤',
            {
              confirmButtonText: 'ç¡®å®šåˆ é™¤',
              cancelButtonText: 'å–æ¶ˆ',
              type: 'warning'
            }
          ).then(() => {
            const index = folders.value.findIndex(f => f.id === folder.id);
            if (index !== -1) {
              folders.value.splice(index, 1);
              contextMenuVisible.value = false;
              hasChanges.value = true;
              ElementPlus.ElMessage({
                message: `æ–‡ä»¶å¤¹ã€Œ${folder.name}ã€å·²æˆåŠŸåˆ é™¤`,
                type: 'success'
              });
            }
          }).catch(() => {
            contextMenuVisible.value = false;
            ElementPlus.ElMessage({
              type: 'info',
              message: 'å·²å–æ¶ˆåˆ é™¤'
            });
          });
        };

        // å¤„ç†å®¹å™¨ç‚¹å‡»äº‹ä»¶
        const handleContainerClick = (event) => {
          // å¦‚æœç‚¹å‡»çš„æ˜¯å®¹å™¨æœ¬èº«ï¼Œè€Œä¸æ˜¯å®¹å™¨å†…çš„æ–‡ä»¶å¤¹
          if (event.target === event.currentTarget) {
            // å¦‚æœæ²¡æœ‰æŒ‰ä¸‹Ctrlé”®ï¼Œæ¸…é™¤é€‰ä¸­çŠ¶æ€
            if (!ctrlKeyPressed.value && !shiftKeyPressed.value) {
              selectedFolders.value = [];
              lastSelectedIndex.value = -1;
            }
          }
        };
        
        // é¼ æ ‡æ‚¬åœåœ¨æ–‡ä»¶å¤¹ä¸Š
        const onFolderMouseOver = (folder) => {
          hoveredFolderId.value = folder.id;
        };
        
        // é¼ æ ‡ç§»å‡ºæ–‡ä»¶å¤¹
        const onFolderMouseLeave = (folder) => {
          if (hoveredFolderId.value === folder.id) {
            hoveredFolderId.value = null;
          }
        };
        
        // å…¨é€‰æ–‡ä»¶å¤¹
        const selectAllFolders = () => {
          if (folders.value.length > 0) {
            selectedFolders.value = folders.value.map(f => f.id);
            lastSelectedIndex.value = folders.value.length - 1;
            ElementPlus.ElMessage({
              message: `å·²é€‰æ‹©å…¨éƒ¨ ${folders.value.length} ä¸ªé¡¹ç›®`,
              type: 'success',
              duration: 1500
            });
          }
          contextMenuVisible.value = false;
        };
        
        // æ¸…é™¤é€‰ä¸­çŠ¶æ€
        const clearSelection = () => {
          selectedFolders.value = [];
          lastSelectedIndex.value = -1;
          contextMenuVisible.value = false;
        };
        
        // å¼€å§‹æ‹–æ‹½æ–‡ä»¶å¤¹
        const onFolderDragStart = (event, folder, index) => {
          // å¦‚æœæ­£åœ¨ç¼–è¾‘æ–‡ä»¶å¤¹ï¼Œä¸å…è®¸æ‹–æ‹½
          if (editingFolder.value) return;
          
          // å¦‚æœæ­£åœ¨æ¡†é€‰ï¼Œä¸å…è®¸æ‹–æ‹½
          if (isSelectionActive.value) return;
          
          // åªæœ‰é¼ æ ‡å·¦é”®å¯ä»¥æ‹–æ‹½
          if (event.button !== 0) return;
          
          // è®°å½•é¼ æ ‡åæ ‡å…è®¸åˆ¤æ–­ç§»åŠ¨è·ç¦»
          dragStartX.value = event.clientX;
          dragStartY.value = event.clientY;
          
          // æ·»åŠ æ–‡æ¡£çº§äº‹ä»¶ç›‘å¬
          document.addEventListener('mousemove', checkDragThreshold);
          document.addEventListener('mouseup', cancelDragStart);
          
          // æ£€æŸ¥ç”¨æˆ·ä¸€å®šè·ç¦»åå¼€å§‹æ‹–æ‹½ (é¿å…ç‚¹å‡»è¢«è¯¯è®¤ä¸ºæ‹–æ‹½)
          function checkDragThreshold(e) {
            const dx = Math.abs(e.clientX - dragStartX.value);
            const dy = Math.abs(e.clientY - dragStartY.value);
            
            // å¦‚æœç§»åŠ¨5åƒç´ ä»¥ä¸Šï¼Œè®¤ä¸ºæ˜¯æ‹–æ‹½æ“ä½œ
            if (dx > 5 || dy > 5) {
              document.removeEventListener('mousemove', checkDragThreshold);
              document.removeEventListener('mouseup', cancelDragStart);
              
              // æ ‡è®°æ‹–æ‹½çŠ¶æ€
              isDraggingFolder.value = true;
              draggedFolder.value = folder;
              
              // æ·»åŠ æ–‡æ¡£çº§çš„äº‹ä»¶å¤„ç†
              document.addEventListener('mousemove', handleDocumentMouseMove);
              document.addEventListener('mouseup', handleDocumentMouseUp);
            }
          }
          
          function cancelDragStart() {
            document.removeEventListener('mousemove', checkDragThreshold);
            document.removeEventListener('mouseup', cancelDragStart);
          }
          
          function handleDocumentMouseMove(e) {
            if (!isDraggingFolder.value) return;
            
            // é˜»æ­¢é»˜è®¤è¡Œä¸º
            e.preventDefault();
            
            // è·å–å½“å‰é¼ æ ‡ä½ç½®ä¸‹çš„å…ƒç´ 
            const elementsUnderCursor = document.elementsFromPoint(e.clientX, e.clientY);
            
            // æŸ¥æ‰¾å…ƒç´ ä¸‹çš„æ–‡ä»¶å¤¹å…ƒç´ 
            const folderElement = elementsUnderCursor.find(el => 
              el.classList.contains('folder-item') && 
              (!draggedFolder.value || el.getAttribute('data-id') !== draggedFolder.value.id)
            );
            
            // å¦‚æœé¼ æ ‡ä¸‹æœ‰æ–‡ä»¶å¤¹å…ƒç´ ï¼Œæ›´æ–°æ‚¬æµ®æ–‡ä»¶å¤¹
            if (folderElement) {
              const folderId = folderElement.getAttribute('data-id');
              dragOverFolder.value = folders.value.find(f => f.id.toString() === folderId);
            } else {
              dragOverFolder.value = null;
            }
          }
          
          function handleDocumentMouseUp(e) {
            // ç§»é™¤æ–‡æ¡£çº§äº‹ä»¶ç›‘å¬
            document.removeEventListener('mousemove', handleDocumentMouseMove);
            document.removeEventListener('mouseup', handleDocumentMouseUp);
            
            // å¦‚æœæ²¡æœ‰å®Œæˆæ‹–æ‹½ï¼Œç›´æ¥è¿”å›
            if (!isDraggingFolder.value) return;
            
            // å¦‚æœæœ‰ç›®æ ‡æ–‡ä»¶å¤¹ï¼Œè¿›è¡Œäº¤æ¢
            if (dragOverFolder.value && draggedFolder.value) {
              swapFolders(draggedFolder.value, dragOverFolder.value);
            }
            
            // é‡ç½®æ‹–æ‹½çŠ¶æ€
            isDraggingFolder.value = false;
            draggedFolder.value = null;
            dragOverFolder.value = null;
          }
        };
        
        // å®ç°HTML5åŸç”Ÿæ‹–æ‹½åŠŸèƒ½
        
        // å¼€å§‹æ‹–æ‹½
        const handleDragStart = (event, folder, index) => {
          // å¦‚æœæ­£åœ¨ç¼–è¾‘æ–‡ä»¶å¤¹ï¼Œä¸å…è®¸æ‹–æ‹½
          if (editingFolder.value) {
            event.preventDefault();
            return;
          }
          
          // å¦‚æœæ­£åœ¨æ¡†é€‰ï¼Œä¸å…è®¸æ‹–æ‹½
          if (isSelectionActive.value) {
            event.preventDefault();
            return;
          }
          
          // è®¾ç½®æ‹–æ‹½æ•°æ®
          event.dataTransfer.effectAllowed = 'move';
          event.dataTransfer.setData('text/plain', folder.id);
          
          // è®°å½•å½“å‰æ‹–æ‹½çš„æ–‡ä»¶å¤¹
          draggedFolder.value = folder;
          
          // æ·»åŠ æ ·å¼æ ‡è®°æ‹–æ‹½ä¸­
          event.target.classList.add('dragging');
          
          // è®¾ç½®åŠé€æ˜æ•ˆæœ
          setTimeout(() => {
            event.target.style.opacity = '0.4';
          }, 0);
        };
        
        // æ‹–æ‹½ç»è¿‡å…¶ä»–æ–‡ä»¶å¤¹ä¸Šæ–¹
        const handleDragOver = (event, folder, index) => {
          // å¦‚æœæ²¡æœ‰åœ¨æ‹–æ‹½æ–‡ä»¶å¤¹ï¼Œåˆ™å¿½ç•¥
          if (!draggedFolder.value) return;
          
          // ä¸èƒ½æ‹–æ‹½åˆ°è‡ªå·±ä¸Šé¢
          if (draggedFolder.value.id === folder.id) return;
          
          // é˜²æ­¢é»˜è®¤è¡Œä¸º
          event.preventDefault();
          
          // ç½®ç©ºæ•ˆæœä¸ºç§»åŠ¨
          event.dataTransfer.dropEffect = 'move';
          
          // æ›´æ–°å½“å‰æ‚¬æµ®åœ¨å“ªä¸ªæ–‡ä»¶å¤¹ä¸Š
          dragOverFolder.value = folder;
        };
        
        // æ”¾ä¸‹å®Œæˆæ‹–æ‹½
        const handleDrop = (event, folder, index) => {
          // é˜²æ­¢é»˜è®¤è¡Œä¸º
          event.preventDefault();
          
          // å¦‚æœæ²¡æœ‰æ‹–æ‹½çš„æ–‡ä»¶å¤¹æˆ–è€…æ‹–æ‹½åˆ°è‡ªå·±ä¸Šé¢ï¼Œåˆ™å¿½ç•¥
          if (!draggedFolder.value || draggedFolder.value.id === folder.id) {
            return;
          }
          
          // è·å–æ‹–æ‹½æ–‡ä»¶å¤¹ID
          const draggedId = event.dataTransfer.getData('text/plain');
          const sourceFolder = folders.value.find(f => f.id.toString() === draggedId);
          
          // å¦‚æœæ²¡æœ‰æ‰¾åˆ°æºæ–‡ä»¶å¤¹ï¼Œåˆ™å¿½ç•¥
          if (!sourceFolder) return;
          
          // äº¤æ¢ä½ç½®
          swapFolders(sourceFolder, folder);
          
          // é‡ç½®æ‹–æ‹½çŠ¶æ€
          draggedFolder.value = null;
          dragOverFolder.value = null;
        };
        
        // äº¤æ¢ä¸¤ä¸ªæ–‡ä»¶å¤¹çš„ä½ç½®
        const swapFolders = (sourceFolder, targetFolder) => {
          // è·å–ä¸¤ä¸ªæ–‡ä»¶å¤¹çš„ç´¢å¼•
          const sourceIndex = folders.value.findIndex(f => f.id === sourceFolder.id);
          const targetIndex = folders.value.findIndex(f => f.id === targetFolder.id);
          
          // æ£€æŸ¥æœ‰æ•ˆæ€§
          if (sourceIndex < 0 || targetIndex < 0 || sourceIndex === targetIndex) return;
          
          // åˆ›å»ºæ–°æ•°ç»„å¹¶é‡æ–°æ’åº
          const newFolders = [...folders.value];
          
          // å…ˆç§»é™¤æºæ–‡ä»¶å¤¹
          const [removedFolder] = newFolders.splice(sourceIndex, 1);
          
          // è®¡ç®—æ’å…¥ç´¢å¼•ï¼ˆæ ¹æ®åˆ é™¤æ“ä½œåçš„æ•°ç»„çŠ¶æ€ï¼‰
          let insertIndex = targetIndex;
          if (sourceIndex < targetIndex) {
            insertIndex--;
          }
          
          // åœ¨ç›®æ ‡ä½ç½®æ’å…¥
          newFolders.splice(insertIndex + 1, 0, removedFolder);
          
          // æ›´æ–°æ–‡ä»¶å¤¹æ•°ç»„
          folders.value = newFolders;
          
          // æ ‡è®°å·²ä¿®æ”¹
          hasChanges.value = true;
          
          // ä¿å­˜æ•°æ®
          saveData();
          
          // æ˜¾ç¤ºæˆåŠŸæç¤º
          ElementPlus.ElMessage({
            message: 'æ–‡ä»¶å¤¹é¡ºåºå·²æ›´æ–°',
            type: 'success',
            duration: 1500
          });
        };
        
        // å¼€å§‹æ¡†é€‰
        const startDragSelection = (event) => {
          // åªæœ‰åœ¨å·¦é”®ç‚¹å‡»ä¸”ç‚¹å‡»åœ¨å®¹å™¨æœ¬èº«ä¸Šæ—¶æ‰å¯åŠ¨æ¡†é€‰
          if (event.button !== 0 || event.target !== event.currentTarget) return;
          
          // è®°å½•èµ·å§‹ç‚¹åæ ‡
          selectionStart.value = { 
            x: event.clientX, 
            y: event.clientY 
          };
          selectionCurrent.value = { 
            x: event.clientX, 
            y: event.clientY 
          };
          
          // éªŒè¯æ˜¯å¦æ˜¯å®é™…çš„æ‹–åŠ¨è¡Œä¸ºï¼ˆé˜²æ­¢å•å‡»æ—¶è§¦å‘ï¼‰
          document.addEventListener('mousemove', checkDragThreshold);
          document.addEventListener('mouseup', cancelDragCheck);
          
          function checkDragThreshold(e) {
            const dx = Math.abs(e.clientX - selectionStart.value.x);
            const dy = Math.abs(e.clientY - selectionStart.value.y);
            
            // å¦‚æœç§»åŠ¨è¶…è¿‡5åƒç´ ï¼Œè®¤ä¸ºæ˜¯æ‹–åŠ¨è¡Œä¸º
            if (dx > 5 || dy > 5) {
              document.removeEventListener('mousemove', checkDragThreshold);
              document.removeEventListener('mouseup', cancelDragCheck);
              
              // æ¿€æ´»æ¡†é€‰
              isSelectionActive.value = true;
              
              // å¦‚æœæ²¡æœ‰æŒ‰ä¸‹Ctrlé”®ï¼Œæ¸…é™¤ä¹‹å‰çš„é€‰æ‹©
              if (!ctrlKeyPressed.value && !shiftKeyPressed.value) {
                // æ¸…é™¤æ•°ç»„
                selectedFolders.value = [];
                selectedFolder.value = null;
                
                // æ¸…é™¤æ‰€æœ‰é€‰ä¸­æ ·å¼ï¼Œç¡®ä¿è§†è§‰ä¸Šçš„ä¸€è‡´æ€§
                const items = document.querySelectorAll('.folder-item');
                items.forEach(item => {
                  item.classList.remove('selected');
                });
              }
            }
          }
          
          function cancelDragCheck() {
            document.removeEventListener('mousemove', checkDragThreshold);
            document.removeEventListener('mouseup', cancelDragCheck);
          }
          
          // è®°å½•æ‰€æœ‰æ–‡ä»¶å¤¹å…ƒç´ çš„ä½ç½®
          const container = document.querySelector('.folder-container');
          const items = container.querySelectorAll('.folder-item');
          folderElements.value = Array.from(items).map((el, index) => {
            const rect = el.getBoundingClientRect();
            return {
              id: folders.value[index].id,
              left: rect.left,
              top: rect.top,
              right: rect.right,
              bottom: rect.bottom,
              element: el  // ä¿å­˜DOMå…ƒç´ å¼•ç”¨ä»¥ä¾¿ç›´æ¥æ“ä½œ
            };
          });
        };
        
        // æ›´æ–°æ¡†é€‰
        const updateDragSelection = (event) => {
          if (!isSelectionActive.value) return;
          
          // æ›´æ–°å½“å‰ä½ç½®
          selectionCurrent.value = { x: event.clientX, y: event.clientY };
          
          // è®¡ç®—é€‰æ‹©æ¡†çš„åæ ‡
          const selectionBox = {
            left: Math.min(selectionStart.value.x, selectionCurrent.value.x),
            top: Math.min(selectionStart.value.y, selectionCurrent.value.y),
            right: Math.max(selectionStart.value.x, selectionCurrent.value.x),
            bottom: Math.max(selectionStart.value.y, selectionCurrent.value.y)
          };
          
          // åªåœ¨å¼€å§‹æ‹–åŠ¨æ—¶è·å–ä¸€æ¬¡å…ƒç´ ï¼Œç„¶åç¼“å­˜å®ƒä»¬
          if (folderElements.value.length === 0) {
            const container = document.querySelector('.folder-container');
            const items = container.querySelectorAll('.folder-item');
            
            folderElements.value = Array.from(items).map((el, index) => {
              const rect = el.getBoundingClientRect();
              const folderId = folders.value[index].id;
              
              return {
                id: folderId,
                left: rect.left,
                top: rect.top,
                right: rect.right,
                bottom: rect.bottom,
                element: el,
                selected: selectedFolders.value.includes(folderId)
              };
            });
          }
          
          // è®°å½•æ‰€æœ‰å·²æ›´æ”¹çš„æ–‡ä»¶å¤¹ID
          const prevSelectedIds = [...selectedFolders.value];
          
          // å¦‚æœä¸æ˜¯å¤šé€‰æ¨¡å¼ï¼Œä¸´æ—¶æ¸…ç©ºé€‰æ‹©æ•°ç»„ï¼ˆä½†ä¸å½±å“UIï¼ŒUIä¼šåœ¨åé¢æ›´æ–°ï¼‰
          if (!ctrlKeyPressed.value && !shiftKeyPressed.value) {
            selectedFolders.value = [];
          }
          
          // æ£€æŸ¥æ¯ä¸ªæ–‡ä»¶å¤¹æ˜¯å¦åœ¨é€‰æ‹©æ¡†å†…
          folderElements.value.forEach(folder => {
            // æ£€æŸ¥é‡å  - åªè¦æœ‰éƒ¨åˆ†é‡å å°±ç®—é€‰ä¸­
            const isIntersecting = !(folder.right < selectionBox.left || 
                                 folder.left > selectionBox.right || 
                                 folder.bottom < selectionBox.top || 
                                 folder.top > selectionBox.bottom);
            
            if (isIntersecting) {
              // æ·»åŠ åˆ°é€‰ä¸­æ•°ç»„
              if (!selectedFolders.value.includes(folder.id)) {
                selectedFolders.value.push(folder.id);
              }
              
              // æ›´æ–°è§†è§‰æ•ˆæœ
              if (!folder.element.classList.contains('selected')) {
                folder.element.classList.add('selected');
                folder.selected = true;
              }
            } else if (!ctrlKeyPressed.value && !shiftKeyPressed.value) {
              // å¦‚æœä¸åœ¨æ¡†å†…ä¸”ä¸æ˜¯å¤šé€‰æ¨¡å¼ï¼Œåˆ™ç§»é™¤
              folder.element.classList.remove('selected');
              folder.selected = false;
            }
          });
          
          // è§¦å‘äº‹ä»¶å‘ŠçŸ¥Vueå·²æ›´æ–°DOM
          if (selectedFolders.value.length > 0) {
            // å°è¯•ä½¿ç”¨è‡ªå®šä¹‰äº‹ä»¶é€šçŸ¥Vueæ›´æ–°
            window.dispatchEvent(new CustomEvent('selectionChanged', {
              detail: { selectedIds: selectedFolders.value }
            }));
          }
        };
        
        // ç»“æŸæ¡†é€‰
        const endDragSelection = (event) => {
          if (!isSelectionActive.value) return;
          
          // ç»“æŸæ¡†é€‰çŠ¶æ€
          isSelectionActive.value = false;
          
          // æ¸…ç©ºè®°å½•çš„æ–‡ä»¶å¤¹å…ƒç´ æ•°ç»„ï¼Œä¸‹æ¬¡é‡æ–°è·å–
          folderElements.value = [];
          
          // å¦‚æœæ²¡æœ‰é€‰æ‹©ä»»ä½•æ–‡ä»¶å¤¹ï¼Œç»“æŸå¤„ç†
          if (selectedFolders.value.length === 0) {
            return;
          }
          
          // æ›´æ–°æœ€åé€‰æ‹©çš„ç´¢å¼•ï¼Œç”¨äºShiftå¤šé€‰
          const lastSelectedId = selectedFolders.value[selectedFolders.value.length - 1];
          const index = folders.value.findIndex(f => f.id === lastSelectedId);
          if (index !== -1) {
            lastSelectedIndex.value = index;
          }
          
          // æ›´æ–°å½“å‰é€‰ä¸­çš„æ–‡ä»¶å¤¹ï¼ˆç”¨äºå³é”®èœå•ç­‰ï¼‰
          if (selectedFolders.value.length === 1) {
            const folder = folders.value.find(f => f.id === selectedFolders.value[0]);
            if (folder) {
              selectedFolder.value = folder;
            }
          } else if (selectedFolders.value.length > 1) {
            selectedFolder.value = null;
          } else {
            selectedFolder.value = null;
          }
          
          // æ˜¾ç¤ºé€‰æ‹©ä¿¡æ¯åé¦ˆ
          ElementPlus.ElMessage({
            message: `å·²é€‰æ‹© ${selectedFolders.value.length} ä¸ªé¡¹ç›®`,
            type: 'success',
            duration: 1500
          });
          
          // ç¡®ä¿DOMå’Œæ•°æ®çš„åŒæ­¥
          // è·å–æ‰€æœ‰æ–‡ä»¶å¤¹å…ƒç´ 
          const items = document.querySelectorAll('.folder-item');
          
          // ç¡®ä¿é€‰ä¸­çŠ¶æ€ä¸è§†è§‰æ•ˆæœä¸€è‡´
          items.forEach((el, idx) => {
            const folderId = folders.value[idx].id;
            const isSelected = selectedFolders.value.includes(folderId);
            
            if (isSelected && !el.classList.contains('selected')) {
              el.classList.add('selected');
            } else if (!isSelected && el.classList.contains('selected')) {
              el.classList.remove('selected');
            }
          });
        };
        
        // ç‚¹å‡»å…¶ä»–åŒºåŸŸå…³é—­å³é”®èœå•
        const handleClickOutside = () => {
          contextMenuVisible.value = false;
        };

        // å¤„ç†æŒ‰é”®äº‹ä»¶
        const handleKeyDown = (event) => {
          // è®°å½•ä¿®æ”¹é”®çŠ¶æ€
          ctrlKeyPressed.value = event.ctrlKey || event.metaKey; // metaKey æ˜¯ Mac ä¸Šçš„ Command é”®
          shiftKeyPressed.value = event.shiftKey;
          
          // ESCé”®å…³é—­èœå•æˆ–å–æ¶ˆé€‰æ‹©
          if (event.key === 'Escape') {
            contextMenuVisible.value = false;
            if (selectedFolders.value.length > 0) {
              selectedFolders.value = [];
              lastSelectedIndex.value = -1;
            }
          }
          
          // Ctrl+A å…¨é€‰
          if ((event.ctrlKey || event.metaKey) && event.key === 'a') {
            event.preventDefault(); // é˜²æ­¢æµè§ˆå™¨é»˜è®¤å…¨é€‰è¡Œä¸º
            if (folders.value.length > 0) {
              selectedFolders.value = folders.value.map(f => f.id);
            }
          }
          
          // Ctrl+C å¤åˆ¶é€‰ä¸­é¡¹
          if ((event.ctrlKey || event.metaKey) && event.key === 'c') {
            if (selectedFolders.value.length > 0) {
              copySelectedFolders();
            }
          }
          
          // Ctrl+V ç²˜è´´
          if ((event.ctrlKey || event.metaKey) && event.key === 'v') {
            pasteFolder();
          }
          
          // Delete é”®åˆ é™¤
          if (event.key === 'Delete') {
            if (selectedFolders.value.length > 0) {
              deleteSelectedFolders();
            }
          }
        };
        
        // å¤„ç†æŒ‰é”®æ¾å¼€äº‹ä»¶
        const handleKeyUp = (event) => {
          ctrlKeyPressed.value = event.ctrlKey || event.metaKey;
          shiftKeyPressed.value = event.shiftKey;
        };

        // å¤„ç†æ‹–æ”¾æ–‡ä»¶å¤¹
        const onDragOver = (event) => {
          isDragging.value = true;
          isDraggingActive.value = true;
        };
        
        const onDragLeave = (event) => {
          isDraggingActive.value = false;
        };
        
        const onDrop = async (event) => {
          isDragging.value = false;
          isDraggingActive.value = false;
          
          // å¤„ç†æ‹–æ”¾çš„æ–‡ä»¶æˆ–æ–‡ä»¶å¤¹
          const items = event.dataTransfer.items;
          if (items) {
            for (let i = 0; i < items.length; i++) {
              const item = items[i];
              // å°è¯•ä½œä¸ºæ–‡ä»¶å¤¹å¤„ç†
              if (item.webkitGetAsEntry) {
                const entry = item.webkitGetAsEntry();
                if (entry && entry.isDirectory) {
                  await processDirectoryEntry(entry);
                } else if (entry && entry.isFile) {
                  // å¦‚æœæ˜¯æ–‡ä»¶ï¼Œä½œä¸ºå•ç‹¬æ–‡ä»¶å¤„ç†
                  processFileEntry(entry);
                }
              }
            }
          }
        };
        
        // å¤„ç†æ–‡ä»¶å¤¹å…¥å£
        const processDirectoryEntry = async (entry) => {
          try {
            if (folders.value.length >= 20) {
              ElementPlus.ElMessage.warning("æœ€å¤šæ–‡ä»¶å¤¹åªèƒ½åˆ›å»º 20 ä¸ª,è¯·å…ˆç§»é™¤éƒ¨åˆ†åï¼Œå†æ·»åŠ !");
              return;
            }
            
            // æ£€æŸ¥æ˜¯å¦æœ‰é‡åæ–‡ä»¶å¤¹
            if (folders.value.some(f => f.name === entry.name)) {
              // ç”Ÿæˆæ–°åç§°
              let baseName = entry.name;
              let extension = '';
              let newName = baseName;
              let counter = 1;
              
              // å¦‚æœæœ‰æ‰©å±•åï¼Œåˆ†å¼€å¤„ç†
              const lastDotIndex = baseName.lastIndexOf('.');
              if (lastDotIndex > 0) {
                extension = baseName.substring(lastDotIndex);
                baseName = baseName.substring(0, lastDotIndex);
              }
              
              // ç”Ÿæˆéé‡å¤åç§°
              while (folders.value.some(f => f.name === newName)) {
                newName = `${baseName}(${counter})${extension}`;
                counter++;
              }
              
              // åˆ›å»ºä¸€ä¸ªæ–°æ–‡ä»¶å¤¹
              const newFolder = {
                id: nextId++,
                name: newName,
                children: []
              };
              
              folders.value.push(newFolder);
              hasChanges.value = true;
              
              // æ˜¾ç¤ºé‡å‘½åæç¤º
              ElementPlus.ElMessage({
                message: `å·²å­˜åœ¨åŒåæ–‡ä»¶å¤¹ï¼Œå·²è‡ªåŠ¨é‡å‘½åä¸º: ${newName}`,
                type: 'warning',
                duration: 3000
              });
            } else {
              // åˆ›å»ºä¸€ä¸ªæ–°æ–‡ä»¶å¤¹
              const newFolder = {
                id: nextId++,
                name: entry.name,
                children: []
              };
              
              folders.value.push(newFolder);
              hasChanges.value = true;
              
              // æ˜¾ç¤ºæˆåŠŸæç¤º
              ElementPlus.ElMessage({
                message: `æˆåŠŸæ·»åŠ æ–‡ä»¶å¤¹: ${entry.name}`,
                type: 'success',
                duration: 2000
              });
            }
          } catch (error) {
            console.error('å¤„ç†æ–‡ä»¶å¤¹å‡ºé”™:', error);
            ElementPlus.ElMessage.error('å¤„ç†æ–‡ä»¶å¤¹å‡ºé”™: ' + error.message);
          }
        };
        
        // å¤„ç†æ–‡ä»¶å…¥å£
        const processFileEntry = (entry) => {
          if (folders.value.length >= 20) {
            ElementPlus.ElMessage.warning("æœ€å¤šæ–‡ä»¶å¤¹åªèƒ½åˆ›å»º 20 ä¸ª,è¯·å…ˆç§»é™¤éƒ¨åˆ†åï¼Œå†æ·»åŠ !");
            return;
          }
          
          // æ£€æŸ¥æ˜¯å¦æœ‰é‡åæ–‡ä»¶
          if (folders.value.some(f => f.name === entry.name)) {
            // ç”Ÿæˆæ–°åç§°
            let baseName = entry.name;
            let extension = '';
            let newName = baseName;
            let counter = 1;
            
            // å¦‚æœæœ‰æ‰©å±•åï¼Œåˆ†å¼€å¤„ç†
            const lastDotIndex = baseName.lastIndexOf('.');
            if (lastDotIndex > 0) {
              extension = baseName.substring(lastDotIndex);
              baseName = baseName.substring(0, lastDotIndex);
            }
            
            // ç”Ÿæˆéé‡å¤åç§°
            while (folders.value.some(f => f.name === newName)) {
              newName = `${baseName}(${counter})${extension}`;
              counter++;
            }
            
            // ä¸ºæ–‡ä»¶åˆ›å»ºæ–‡ä»¶å¤¹è§†å›¾
            const newFolder = {
              id: nextId++,
              name: newName,
              isFile: true
            };
            
            folders.value.push(newFolder);
            hasChanges.value = true;
            
            // æ˜¾ç¤ºé‡å‘½åæç¤º
            ElementPlus.ElMessage({
              message: `å·²å­˜åœ¨åŒåæ–‡ä»¶ï¼Œå·²è‡ªåŠ¨é‡å‘½åä¸º: ${newName}`,
              type: 'warning',
              duration: 3000
            });
          } else {
            // ä¸ºæ–‡ä»¶åˆ›å»ºæ–‡ä»¶å¤¹è§†å›¾
            const newFolder = {
              id: nextId++,
              name: entry.name,
              isFile: true
            };
            
            folders.value.push(newFolder);
            hasChanges.value = true;
            
            // æ˜¾ç¤ºæˆåŠŸæç¤º
            ElementPlus.ElMessage({
              message: `æˆåŠŸæ·»åŠ æ–‡ä»¶: ${entry.name}`,
              type: 'success',
              duration: 2000
            });
          }
        };
        const clearData = () => {
          ElementPlus.ElMessageBox.confirm(
            'æ˜¯å¦è¦æ¸…ç©ºæ‰€æœ‰çš„æ–‡ä»¶å¤¹åˆ—è¡¨?',
            'Warning',
            {
              confirmButtonText: 'åŒæ„',
              cancelButtonText: 'å–æ¶ˆ',
              type: 'warning',
            }
          )
          .then(() => {
            ElementPlus.ElMessage({
              type: 'success',
              message: 'åˆ é™¤æˆåŠŸ',
            });
            localStorage.removeItem('folderManager');
            folders.value = [];
            nextId = 1;
            hasChanges.value = false;
            originalData.value = '';
          })
          .catch(() => {
            ElementPlus.ElMessage({
              type: 'info',
              message: 'æœªåˆ é™¤',
            });
          });
        }
        // ä¿å­˜æ•°æ®åˆ°æœ¬åœ°å­˜å‚¨
        const saveData = () => {
          try {
            // æ£€æŸ¥æ˜¯å¦æœ‰å˜æ›´
            const currentData = JSON.stringify({
              folders: folders.value,
              nextId: nextId
            });
            
            if (!hasChanges.value && currentData === originalData.value) {
              // ä½¿ç”¨ Element Plus æ˜¾ç¤ºæç¤º
              ElementPlus.ElMessage({
                message: 'æ²¡æœ‰æ£€æµ‹åˆ°æ–‡ä»¶å¤¹å˜æ›´ï¼Œæ— éœ€ä¿å­˜',
                type: 'warning',
                duration: 2000
              });
              return;
            }
            
            localStorage.setItem('folderManager', currentData);
            
            // æ›´æ–°åŸå§‹æ•°æ®
            originalData.value = currentData;
            hasChanges.value = false;
            
            // ä½¿ç”¨ Element Plus æ˜¾ç¤ºæˆåŠŸæç¤º
            ElementPlus.ElMessage({
              message: 'æ•°æ®å·²æˆåŠŸä¿å­˜åˆ°æœ¬åœ°',
              type: 'success',
              duration: 2000
            });
            
            console.log('æ•°æ®å·²ä¿å­˜åˆ°æœ¬åœ°');
          } catch (error) {
            console.error('ä¿å­˜æ•°æ®å‡ºé”™:', error);
            
            // ä½¿ç”¨ Element Plus æ˜¾ç¤ºé”™è¯¯æç¤º
            ElementPlus.ElMessage({
              message: 'ä¿å­˜æ•°æ®æ—¶å‡ºé”™: ' + error.message,
              type: 'error',
              duration: 3000
            });
          }
        };
        
        // ä»æœ¬åœ°å­˜å‚¨åŠ è½½æ•°æ®
        const loadData = () => {
          try {
            const savedData = localStorage.getItem('folderManager');
            if (savedData) {
              const parsedData = JSON.parse(savedData);
              folders.value = parsedData.folders || [];
              nextId = parsedData.nextId || 1;
              console.log('æ•°æ®å·²ä»æœ¬åœ°åŠ è½½');
              
              // ä¿å­˜åŸå§‹æ•°æ®ç”¨äºå˜æ›´æ£€æµ‹
              originalData.value = savedData;
              hasChanges.value = false;
            }
          } catch (error) {
            console.error('åŠ è½½æ•°æ®å‡ºé”™:', error);
            ElementPlus.ElMessage.error('åŠ è½½æ•°æ®æ—¶å‡ºé”™: ' + error.message);
          }
        };
        
        // ç›‘å¬é¡µé¢å…³é—­äº‹ä»¶ä»¥è‡ªåŠ¨ä¿å­˜
        const handleBeforeUnload = () => {
          if (hasChanges.value) {
            saveData();
          }
        };
        
        // å¤„ç†æ–‡ä»¶å¤¹ç‚¹å‡»
        const handleFolderClick = (folder, index, event) => {
          // é˜²æ­¢åœ¨ç¼–è¾‘æ¨¡å¼ä¸‹è§¦å‘é€‰æ‹©
          if (editingFolder.value) return;
          
          // å¦‚æœæ˜¯åŒå‡»ï¼Œäº¤ç»™åŒå‡»äº‹ä»¶å¤„ç†
          if (event.detail > 1) return;
          
          // å¦‚æœæ˜¯å³é”®ï¼Œäº¤ç»™èœå•å¤„ç†
          if (event.button === 2) return;
          
          // å½“æŒ‰ä¸‹ Ctrl æˆ– Command é”®
          if (ctrlKeyPressed.value) {
            const idIndex = selectedFolders.value.indexOf(folder.id);
            if (idIndex === -1) {
              // æ·»åŠ åˆ°é€‰ä¸­é¡¹
              selectedFolders.value.push(folder.id);
              lastSelectedIndex.value = index;
            } else {
              // ä»é€‰ä¸­é¡¹ç§»é™¤
              selectedFolders.value.splice(idIndex, 1);
              lastSelectedIndex.value = selectedFolders.value.length > 0 ? index : -1;
            }
          }
          // å½“æŒ‰ä¸‹ Shift é”®
          else if (shiftKeyPressed.value && lastSelectedIndex.value !== -1) {
            // è®¡ç®—èŒƒå›´
            const start = Math.min(lastSelectedIndex.value, index);
            const end = Math.max(lastSelectedIndex.value, index);
            
            // é€‰æ‹©èŒƒå›´å†…çš„æ‰€æœ‰æ–‡ä»¶å¤¹
            selectedFolders.value = [];
            for (let i = start; i <= end; i++) {
              if (i < folders.value.length) {
                selectedFolders.value.push(folders.value[i].id);
              }
            }
          }
          // ä¸æŒ‰ä¿®é¥°é”®æ—¶ï¼Œå•é€‰
          else {
            selectedFolders.value = [folder.id];
            lastSelectedIndex.value = index;
          }
        };
        
        // å¤åˆ¶é€‰ä¸­æ–‡ä»¶å¤¹
        const copySelectedFolders = () => {
          if (selectedFolders.value.length === 0) return;
          
          // å¦‚æœåªé€‰äº†ä¸€ä¸ªæ–‡ä»¶å¤¹ï¼Œä½¿ç”¨å•ä¸ªå¤åˆ¶é€»è¾‘
          if (selectedFolders.value.length === 1) {
            const folder = folders.value.find(f => f.id === selectedFolders.value[0]);
            if (folder) {
              copyFolder(folder);
            }
            return;
          }
          
          // å¤šé€‰å¤åˆ¶é€»è¾‘
          const selectedItems = folders.value.filter(f => selectedFolders.value.includes(f.id));
          
          // å­˜å‚¨åˆ°å†…éƒ¨å‰ªè´´æ¿
          clipboardData.value = {
            type: 'multiple',
            items: selectedItems
          };
          
          ElementPlus.ElMessage({
            message: `å·²å¤åˆ¶ ${selectedItems.length} ä¸ªé¡¹ç›®`,
            type: 'success',
            duration: 1500
          });
        };
        
        // åˆ é™¤é€‰ä¸­æ–‡ä»¶å¤¹
        const deleteSelectedFolders = () => {
          if (selectedFolders.value.length === 0) return;
          
          // å¦‚æœåªé€‰äº†ä¸€ä¸ªæ–‡ä»¶å¤¹ï¼Œä½¿ç”¨å•ä¸ªåˆ é™¤é€»è¾‘
          if (selectedFolders.value.length === 1) {
            const folder = folders.value.find(f => f.id === selectedFolders.value[0]);
            if (folder) {
              deleteFolder(folder);
            }
            return;
          }
          
          // å¤šé€‰åˆ é™¤é€»è¾‘
          ElementPlus.ElMessageBox.confirm(
            `ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${selectedFolders.value.length} ä¸ªé¡¹ç›®å—ï¼Ÿ`,
            'æ‰¹é‡åˆ é™¤',
            {
              confirmButtonText: 'ç¡®å®šåˆ é™¤',
              cancelButtonText: 'å–æ¶ˆ',
              type: 'warning'
            }
          ).then(() => {
            // è®°å½•è¦åˆ é™¤çš„é¡¹ç›®åç§°
            const itemNames = folders.value
              .filter(f => selectedFolders.value.includes(f.id))
              .map(f => f.name)
              .join(', ');
              
            // ä»æ•°ç»„ä¸­è¿‡æ»¤å‡ºè¦åˆ é™¤çš„é¡¹ç›®
            folders.value = folders.value.filter(f => !selectedFolders.value.includes(f.id));
            selectedFolders.value = [];
            lastSelectedIndex.value = -1;
            hasChanges.value = true;
            
            ElementPlus.ElMessage({
              message: `å·²åˆ é™¤é€‰ä¸­é¡¹ç›®: ${itemNames}`,
              type: 'success'
            });
          }).catch(() => {
            ElementPlus.ElMessage({
              type: 'info',
              message: 'å·²å–æ¶ˆåˆ é™¤'
            });
          });
        };
        
        // ç”Ÿå‘½å‘¨æœŸé’©å­
        onMounted(() => {
          document.addEventListener('click', handleClickOutside);
          document.addEventListener('keydown', handleKeyDown);
          document.addEventListener('keyup', handleKeyUp);
          window.addEventListener('beforeunload', handleBeforeUnload);
          
          // åŠ è½½ä¿å­˜çš„æ•°æ®
          loadData();
        });

        onBeforeUnmount(() => {
          document.removeEventListener('click', handleClickOutside);
          document.removeEventListener('keydown', handleKeyDown);
          document.removeEventListener('keyup', handleKeyUp);
          window.removeEventListener('beforeunload', handleBeforeUnload);
        });

        // å¤åˆ¶æ–‡ä»¶å¤¹
        const copyFolder = (folder) => {
          // å­˜å‚¨åœ¨å†…éƒ¨å‰ªè´´æ¿ä¸­
          clipboardData.value = { ...folder };
          
          // å°è¯•å°†æ•°æ®å†™å…¥ç³»ç»Ÿå‰ªè´´æ¿
          try {
            navigator.clipboard.writeText(JSON.stringify(folder))
              .then(() => {
                ElementPlus.ElMessage({
                  message: `å·²å¤åˆ¶æ–‡ä»¶å¤¹ï¼š${folder.name}`,
                  type: 'success',
                  duration: 1500
                });
              })
              .catch(err => {
                console.warn('å†™å…¥ç³»ç»Ÿå‰ªè´´æ¿å‡ºé”™ï¼Œä½†å†…éƒ¨å‰ªè´´æ¿å¯ç”¨', err);
                ElementPlus.ElMessage({
                  message: `å·²å¤åˆ¶æ–‡ä»¶å¤¹ï¼š${folder.name} (ä»…åº”ç”¨å†…å¯ç”¨)`,
                  type: 'success',
                  duration: 1500
                });
              });
          } catch (e) {
            // å¦‚æœæµè§ˆå™¨ä¸æ”¯æŒå‰ªè´´æ¿ APIï¼Œä¾ç„¶å¯ä½¿ç”¨å†…éƒ¨å‰ªè´´æ¿
            ElementPlus.ElMessage({
              message: `å·²å¤åˆ¶æ–‡ä»¶å¤¹ï¼š${folder.name} (ä»…åº”ç”¨å†…å¯ç”¨)`,
              type: 'success',
              duration: 1500
            });
          }
          contextMenuVisible.value = false;
        };
        
        // ç²˜è´´æ–‡ä»¶å¤¹
        const pasteFolder = async () => {
          // æ£€æŸ¥æ•°é‡é™åˆ¶
          if (folders.value.length >= 20) {
            ElementPlus.ElMessage.warning("æœ€å¤šæ–‡ä»¶å¤¹åªèƒ½åˆ›å»º 20 ä¸ª,è¯·å…ˆç§»é™¤éƒ¨åˆ†åï¼Œå†æ·»åŠ !");
            contextMenuVisible.value = false;
            return;
          }
          
          // ä¼˜å…ˆå°è¯•ä½¿ç”¨å†…éƒ¨å‰ªè´´æ¿
          if (clipboardData.value) {
            // æ£€æŸ¥æ˜¯å¦æ˜¯æ‰¹é‡å¤åˆ¶
            if (clipboardData.value.type === 'multiple' && clipboardData.value.items) {
              // æ‰¹é‡ç²˜è´´é€»è¾‘
              const items = clipboardData.value.items;
              
              // æ£€æŸ¥æ˜¯å¦è¶…è¿‡æ•°é‡é™åˆ¶
              if (folders.value.length + items.length > 20) {
                ElementPlus.ElMessage.warning(`æœ€å¤šä»…èƒ½åˆ›å»º 20 ä¸ªé¡¹ç›®ã€‚å½“å‰ ${folders.value.length} ä¸ªï¼Œä¸èƒ½å†æ·»åŠ  ${items.length} ä¸ª`);
                return;
              }
              
              // æ‰¹é‡åˆ›å»ºæ–‡ä»¶å¤¹
              const newFolders = [];
              
              for (const item of items) {
                // ç”Ÿæˆæ–°åç§°é˜²æ­¢é‡å¤
                let baseName = item.name;
                let extension = '';
                let newName = baseName;
                let counter = 1;
                
                // å¦‚æœæœ‰æ‰©å±•åï¼Œåˆ†å¼€å¤„ç†
                const lastDotIndex = baseName.lastIndexOf('.');
                if (lastDotIndex > 0 && item.isFile) {
                  extension = baseName.substring(lastDotIndex);
                  baseName = baseName.substring(0, lastDotIndex);
                }
                
                // æ£€æŸ¥å·²æœ‰æ–‡ä»¶å¤¹åŠæ–°åˆ›å»ºçš„æ–‡ä»¶å¤¹ä¸­æ˜¯å¦æœ‰é‡å
                const existingNames = [...folders.value.map(f => f.name), ...newFolders.map(f => f.name)];
                while (existingNames.includes(newName)) {
                  newName = `${baseName} çš„å‰¯æœ¬${counter > 1 ? ' ' + counter : ''}${extension}`;
                  counter++;
                }
                
                // åˆ›å»ºæ–°æ–‡ä»¶å¤¹
                const newFolder = {
                  id: nextId++,
                  name: newName,
                  isFile: item.isFile || false,
                  children: item.children || []
                };
                
                newFolders.push(newFolder);
              }
              
              // æ·»åŠ åˆ°å½“å‰æ–‡ä»¶å¤¹åˆ—è¡¨
              folders.value.push(...newFolders);
              hasChanges.value = true;
              
              ElementPlus.ElMessage({
                message: `æˆåŠŸç²˜è´´ ${newFolders.length} ä¸ªé¡¹ç›®`,
                type: 'success',
                duration: 1500
              });
              
              contextMenuVisible.value = false;
              return;
            }
            // ç”Ÿæˆæ–°æ–‡ä»¶å¤¹åç§°
            let baseName = clipboardData.value.name;
            let extension = '';
            let newName = baseName;
            let counter = 1;
            
            // å¦‚æœæœ‰æ‰©å±•åï¼Œåˆ†å¼€å¤„ç†
            const lastDotIndex = baseName.lastIndexOf('.');
            if (lastDotIndex > 0 && clipboardData.value.isFile) {
              extension = baseName.substring(lastDotIndex);
              baseName = baseName.substring(0, lastDotIndex);
            }
            
            // æ£€æŸ¥é‡åå¹¶ç”Ÿæˆæ–°åç§°
            while (folders.value.some(f => f.name === newName)) {
              newName = `${baseName} çš„å‰¯æœ¬${counter > 1 ? ' ' + counter : ''}${extension}`;
              counter++;
            }
            
            // åˆ›å»ºæ–°æ–‡ä»¶å¤¹
            const newFolder = {
              id: nextId++,
              name: newName,
              isFile: clipboardData.value.isFile || false,
              children: clipboardData.value.children || []
            };
            
            folders.value.push(newFolder);
            hasChanges.value = true;
            contextMenuVisible.value = false;
            
            ElementPlus.ElMessage({
              message: `æˆåŠŸç²˜è´´æ–‡ä»¶å¤¹: ${newName}`,
              type: 'success',
              duration: 1500
            });
            return;
          }
          
          // å¦‚æœå†…éƒ¨å‰ªè´´æ¿ä¸ºç©ºï¼Œå°è¯•ä»ç³»ç»Ÿå‰ªè´´æ¿è¯»å–
          try {
            const text = await navigator.clipboard.readText();
            try {
              const data = JSON.parse(text);
              if (data && data.name) {
                // ç”Ÿæˆæ–°æ–‡ä»¶å¤¹åç§°
                let baseName = data.name;
                let newName = baseName;
                let counter = 1;
                
                // æ£€æŸ¥é‡åå¹¶ç”Ÿæˆæ–°åç§°
                while (folders.value.some(f => f.name === newName)) {
                  newName = `${baseName} çš„å‰¯æœ¬${counter > 1 ? ' ' + counter : ''}`;
                  counter++;
                }
                
                // åˆ›å»ºæ–°æ–‡ä»¶å¤¹
                const newFolder = {
                  id: nextId++,
                  name: newName,
                  isFile: data.isFile || false
                };
                
                folders.value.push(newFolder);
                hasChanges.value = true;
                contextMenuVisible.value = false;
                
                ElementPlus.ElMessage({
                  message: `æˆåŠŸä»å‰ªè´´æ¿ç²˜è´´: ${newName}`,
                  type: 'success',
                  duration: 1500
                });
              } else {
                throw new Error('æ— æ•ˆçš„æ–‡ä»¶å¤¹æ•°æ®');
              }
            } catch (parseError) {
              // JSON è§£æå¤±è´¥ï¼Œå°è¯•å°†æ–‡æœ¬ä½œä¸ºæ–‡ä»¶ååˆ›å»º
              if (text.trim()) {
                // ç”Ÿæˆæ–°æ–‡ä»¶å¤¹åç§°
                let baseName = text.length > 20 ? text.substring(0, 20) + '...' : text;
                let newName = baseName;
                let counter = 1;
                
                // æ£€æŸ¥é‡åå¹¶ç”Ÿæˆæ–°åç§°
                while (folders.value.some(f => f.name === newName)) {
                  newName = `${baseName} (${counter})`;
                  counter++;
                }
                
                // åˆ›å»ºæ–°æ–‡ä»¶å¤¹
                const newFolder = {
                  id: nextId++,
                  name: newName,
                  isFile: true
                };
                
                folders.value.push(newFolder);
                hasChanges.value = true;
                contextMenuVisible.value = false;
                
                ElementPlus.ElMessage({
                  message: `å·²å°†å‰ªè´´æ¿æ–‡æœ¬åˆ›å»ºä¸ºæ–‡ä»¶: ${newName}`,
                  type: 'success',
                  duration: 1500
                });
              } else {
                ElementPlus.ElMessage({
                  message: 'å‰ªè´´æ¿ä¸­æ— å¯ç²˜è´´çš„å†…å®¹',
                  type: 'warning',
                  duration: 1500
                });
              }
            }
          } catch (error) {
            ElementPlus.ElMessage({
              message: 'æ— æ³•è®¿é—®ç³»ç»Ÿå‰ªè´´æ¿ï¼Œè¯·å…ˆå¤åˆ¶æ–‡ä»¶å¤¹',
              type: 'error',
              duration: 1500
            });
          }
          contextMenuVisible.value = false;
        };

        return {
          folders,
          contextMenuVisible,
          contextMenuTop,
          contextMenuLeft,
          selectedFolder,
          editingFolder,
          editInput,
          tempName,
          isDragging,
          isDraggingActive,
          hasChanges,
          clipboardData,
          selectedFolders,
          hoveredFolderId,
          isSelectionActive,
          selectionStart,
          selectionCurrent,
          showContextMenu,
          createNewFolder,
          startEdit,
          finishEdit,
          cancelEdit,
          deleteFolder,
          copyFolder,
          pasteFolder,
          handleFolderClick,
          handleContainerClick,
          copySelectedFolders,
          deleteSelectedFolders,
          selectAllFolders,
          clearSelection,
          onFolderMouseOver,
          onFolderMouseLeave,
          startDragSelection,
          updateDragSelection,
          endDragSelection,
          // æ‹–æ‹½ç›¸å…³å‡½æ•°
          handleDragStart,
          handleDragOver,
          handleDrop,
          onDragOver,
          onDragLeave,
          onDrop,
          saveData,
          clearData
        };
      }
    });
    
    // ä½¿ç”¨ Element Plus
    app.use(ElementPlus);
    
    // æŒ‚è½½åº”ç”¨
    app.mount('#app');
  </script>
</body>
</html>
